/*
 * This file is generated by jOOQ.
 */
package com.functionaldude.paperless.jooq.paperless_rag.tables


import com.functionaldude.paperless.jooq.paperless_rag.PaperlessRag
import com.functionaldude.paperless.jooq.paperless_rag.indexes.IDX_DOCUMENT_CHUNK_EMBEDDING
import com.functionaldude.paperless.jooq.paperless_rag.keys.DOCUMENT_CHUNK_PKEY
import com.functionaldude.paperless.jooq.paperless_rag.keys.DOCUMENT_CHUNK__DOCUMENT_CHUNK_DOCUMENT_SOURCE_ID_FKEY
import com.functionaldude.paperless.jooq.paperless_rag.keys.UQ_DOCUMENT_CHUNK_DOC_IDX
import com.functionaldude.paperless.jooq.paperless_rag.tables.DocumentSource.DocumentSourcePath
import com.functionaldude.paperless.jooq.paperless_rag.tables.records.DocumentChunkRecord
import org.jooq.*
import org.jooq.impl.*
import org.jooq.impl.Internal
import java.time.OffsetDateTime


/**
 * This class is generated by jOOQ.
 */
@Suppress("UNCHECKED_CAST")
open class DocumentChunk(
  alias: Name,
  path: Table<out Record>?,
  childPath: ForeignKey<out Record, DocumentChunkRecord>?,
  parentPath: InverseForeignKey<out Record, DocumentChunkRecord>?,
  aliased: Table<DocumentChunkRecord>?,
  parameters: Array<Field<*>?>?,
  where: Condition?
) : TableImpl<DocumentChunkRecord>(
  alias,
  PaperlessRag.PAPERLESS_RAG,
  path,
  childPath,
  parentPath,
  aliased,
  parameters,
  DSL.comment(""),
  TableOptions.table(),
  where,
) {
  companion object {

    /**
     * The reference instance of <code>paperless_rag.document_chunk</code>
     */
    val DOCUMENT_CHUNK: DocumentChunk = DocumentChunk()
  }

  /**
   * The class holding records for this type
   */
  override fun getRecordType(): Class<DocumentChunkRecord> = DocumentChunkRecord::class.java

  /**
   * The column <code>paperless_rag.document_chunk.id</code>.
   */
  val ID: TableField<DocumentChunkRecord, Long?> =
    createField(DSL.name("id"), SQLDataType.BIGINT.nullable(false).identity(true), this, "")

  /**
   * The column <code>paperless_rag.document_chunk.document_source_id</code>.
   */
  val DOCUMENT_SOURCE_ID: TableField<DocumentChunkRecord, Int?> =
    createField(DSL.name("document_source_id"), SQLDataType.INTEGER.nullable(false), this, "")

  /**
   * The column <code>paperless_rag.document_chunk.chunk_index</code>.
   */
  val CHUNK_INDEX: TableField<DocumentChunkRecord, Int?> =
    createField(DSL.name("chunk_index"), SQLDataType.INTEGER.nullable(false), this, "")

  /**
   * The column <code>paperless_rag.document_chunk.content</code>.
   */
  val CONTENT: TableField<DocumentChunkRecord, String?> =
    createField(DSL.name("content"), SQLDataType.CLOB.nullable(false), this, "")

  @Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
  val EMBEDDING: TableField<DocumentChunkRecord, Any?> =
    createField(DSL.name("embedding"), DefaultDataType.getDefaultDataType("\"public\".\"vector\""), this, "")

  /**
   * The column <code>paperless_rag.document_chunk.metadata</code>.
   */
  val METADATA: TableField<DocumentChunkRecord, JSONB?> = createField(DSL.name("metadata"), SQLDataType.JSONB, this, "")

  /**
   * The column <code>paperless_rag.document_chunk.created_at</code>.
   */
  val CREATED_AT: TableField<DocumentChunkRecord, OffsetDateTime?> = createField(
    DSL.name("created_at"),
    SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false)
      .defaultValue(DSL.field(DSL.raw("now()"), SQLDataType.TIMESTAMPWITHTIMEZONE)),
    this,
    ""
  )

  private constructor(alias: Name, aliased: Table<DocumentChunkRecord>?) : this(
    alias,
    null,
    null,
    null,
    aliased,
    null,
    null
  )

  private constructor(alias: Name, aliased: Table<DocumentChunkRecord>?, parameters: Array<Field<*>?>?) : this(
    alias,
    null,
    null,
    null,
    aliased,
    parameters,
    null
  )

  private constructor(alias: Name, aliased: Table<DocumentChunkRecord>?, where: Condition?) : this(
    alias,
    null,
    null,
    null,
    aliased,
    null,
    where
  )

  /**
   * Create an aliased <code>paperless_rag.document_chunk</code> table
   * reference
   */
  constructor(alias: String) : this(DSL.name(alias))

  /**
   * Create an aliased <code>paperless_rag.document_chunk</code> table
   * reference
   */
  constructor(alias: Name) : this(alias, null)

  /**
   * Create a <code>paperless_rag.document_chunk</code> table reference
   */
  constructor() : this(DSL.name("document_chunk"), null)

  constructor(
    path: Table<out Record>,
    childPath: ForeignKey<out Record, DocumentChunkRecord>?,
    parentPath: InverseForeignKey<out Record, DocumentChunkRecord>?
  ) : this(
    Internal.createPathAlias(path, childPath, parentPath),
    path,
    childPath,
    parentPath,
    DOCUMENT_CHUNK,
    null,
    null
  )

  /**
   * A subtype implementing {@link Path} for simplified path-based joins.
   */
  open class DocumentChunkPath : DocumentChunk, Path<DocumentChunkRecord> {
    constructor(
      path: Table<out Record>,
      childPath: ForeignKey<out Record, DocumentChunkRecord>?,
      parentPath: InverseForeignKey<out Record, DocumentChunkRecord>?
    ) : super(path, childPath, parentPath)

    private constructor(alias: Name, aliased: Table<DocumentChunkRecord>) : super(alias, aliased)

    override fun `as`(alias: String): DocumentChunkPath = DocumentChunkPath(DSL.name(alias), this)
    override fun `as`(alias: Name): DocumentChunkPath = DocumentChunkPath(alias, this)
    override fun `as`(alias: Table<*>): DocumentChunkPath = DocumentChunkPath(alias.qualifiedName, this)
  }

  override fun getSchema(): Schema? = if (aliased()) null else PaperlessRag.PAPERLESS_RAG
  override fun getIndexes(): List<Index> = listOf(IDX_DOCUMENT_CHUNK_EMBEDDING)
  override fun getIdentity(): Identity<DocumentChunkRecord, Long?> =
    super.getIdentity() as Identity<DocumentChunkRecord, Long?>

  override fun getPrimaryKey(): UniqueKey<DocumentChunkRecord> = DOCUMENT_CHUNK_PKEY
  override fun getUniqueKeys(): List<UniqueKey<DocumentChunkRecord>> = listOf(UQ_DOCUMENT_CHUNK_DOC_IDX)
  override fun getReferences(): List<ForeignKey<DocumentChunkRecord, *>> =
    listOf(DOCUMENT_CHUNK__DOCUMENT_CHUNK_DOCUMENT_SOURCE_ID_FKEY)

  private lateinit var _documentSource: DocumentSourcePath

  /**
   * Get the implicit join path to the
   * <code>paperless_rag.document_source</code> table.
   */
  fun documentSource(): DocumentSourcePath {
    if (!this::_documentSource.isInitialized)
      _documentSource = DocumentSourcePath(this, DOCUMENT_CHUNK__DOCUMENT_CHUNK_DOCUMENT_SOURCE_ID_FKEY, null)

    return _documentSource;
  }

  val documentSource: DocumentSourcePath
    get(): DocumentSourcePath = documentSource()

  override fun `as`(alias: String): DocumentChunk = DocumentChunk(DSL.name(alias), this)
  override fun `as`(alias: Name): DocumentChunk = DocumentChunk(alias, this)
  override fun `as`(alias: Table<*>): DocumentChunk = DocumentChunk(alias.qualifiedName, this)

  /**
   * Rename this table
   */
  override fun rename(name: String): DocumentChunk = DocumentChunk(DSL.name(name), null)

  /**
   * Rename this table
   */
  override fun rename(name: Name): DocumentChunk = DocumentChunk(name, null)

  /**
   * Rename this table
   */
  override fun rename(name: Table<*>): DocumentChunk = DocumentChunk(name.qualifiedName, null)

  /**
   * Create an inline derived table from this table
   */
  override fun where(condition: Condition?): DocumentChunk =
    DocumentChunk(qualifiedName, if (aliased()) this else null, condition)

  /**
   * Create an inline derived table from this table
   */
  override fun where(conditions: Collection<Condition>): DocumentChunk = where(DSL.and(conditions))

  /**
   * Create an inline derived table from this table
   */
  override fun where(vararg conditions: Condition?): DocumentChunk = where(DSL.and(*conditions))

  /**
   * Create an inline derived table from this table
   */
  override fun where(condition: Field<Boolean?>?): DocumentChunk = where(DSL.condition(condition))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(condition: SQL): DocumentChunk = where(DSL.condition(condition))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(@Stringly.SQL condition: String): DocumentChunk = where(DSL.condition(condition))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(@Stringly.SQL condition: String, vararg binds: Any?): DocumentChunk =
    where(DSL.condition(condition, *binds))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(@Stringly.SQL condition: String, vararg parts: QueryPart): DocumentChunk =
    where(DSL.condition(condition, *parts))

  /**
   * Create an inline derived table from this table
   */
  override fun whereExists(select: Select<*>): DocumentChunk = where(DSL.exists(select))

  /**
   * Create an inline derived table from this table
   */
  override fun whereNotExists(select: Select<*>): DocumentChunk = where(DSL.notExists(select))
}

/*
 * This file is generated by jOOQ.
 */
package com.functionaldude.paperless.jooq.paperless_rag.tables


import com.functionaldude.paperless.jooq.paperless_rag.PaperlessRag
import com.functionaldude.paperless.jooq.paperless_rag.indexes.IDX_DOCUMENT_SOURCE_MODIFIED
import com.functionaldude.paperless.jooq.paperless_rag.indexes.IDX_DOCUMENT_SOURCE_STATUS
import com.functionaldude.paperless.jooq.paperless_rag.keys.DOCUMENT_CHUNK__DOCUMENT_CHUNK_DOCUMENT_SOURCE_ID_FKEY
import com.functionaldude.paperless.jooq.paperless_rag.keys.DOCUMENT_SOURCE_PAPERLESS_DOC_ID_KEY
import com.functionaldude.paperless.jooq.paperless_rag.keys.DOCUMENT_SOURCE_PKEY
import com.functionaldude.paperless.jooq.paperless_rag.tables.DocumentChunk.DocumentChunkPath
import com.functionaldude.paperless.jooq.paperless_rag.tables.records.DocumentSourceRecord
import org.jooq.*
import org.jooq.impl.DSL
import org.jooq.impl.Internal
import org.jooq.impl.SQLDataType
import org.jooq.impl.TableImpl
import java.time.LocalDate
import java.time.OffsetDateTime


/**
 * This class is generated by jOOQ.
 */
@Suppress("UNCHECKED_CAST")
open class DocumentSource(
  alias: Name,
  path: Table<out Record>?,
  childPath: ForeignKey<out Record, DocumentSourceRecord>?,
  parentPath: InverseForeignKey<out Record, DocumentSourceRecord>?,
  aliased: Table<DocumentSourceRecord>?,
  parameters: Array<Field<*>?>?,
  where: Condition?
) : TableImpl<DocumentSourceRecord>(
  alias,
  PaperlessRag.PAPERLESS_RAG,
  path,
  childPath,
  parentPath,
  aliased,
  parameters,
  DSL.comment(""),
  TableOptions.table(),
  where,
) {
  companion object {

    /**
     * The reference instance of <code>paperless_rag.document_source</code>
     */
    val DOCUMENT_SOURCE: DocumentSource = DocumentSource()
  }

  /**
   * The class holding records for this type
   */
  override fun getRecordType(): Class<DocumentSourceRecord> = DocumentSourceRecord::class.java

  /**
   * The column <code>paperless_rag.document_source.id</code>.
   */
  val ID: TableField<DocumentSourceRecord, Long?> =
    createField(DSL.name("id"), SQLDataType.BIGINT.nullable(false).identity(true), this, "")

  /**
   * The column <code>paperless_rag.document_source.paperless_doc_id</code>.
   */
  val PAPERLESS_DOC_ID: TableField<DocumentSourceRecord, Int?> =
    createField(DSL.name("paperless_doc_id"), SQLDataType.INTEGER.nullable(false), this, "")

  /**
   * The column <code>paperless_rag.document_source.title</code>.
   */
  val TITLE: TableField<DocumentSourceRecord, String?> =
    createField(DSL.name("title"), SQLDataType.CLOB.nullable(false), this, "")

  /**
   * The column <code>paperless_rag.document_source.correspondent</code>.
   */
  val CORRESPONDENT: TableField<DocumentSourceRecord, String?> =
    createField(DSL.name("correspondent"), SQLDataType.CLOB, this, "")

  /**
   * The column <code>paperless_rag.document_source.doc_date</code>.
   */
  val DOC_DATE: TableField<DocumentSourceRecord, LocalDate?> =
    createField(DSL.name("doc_date"), SQLDataType.LOCALDATE, this, "")

  /**
   * The column
   * <code>paperless_rag.document_source.paperless_modified_at</code>.
   */
  val PAPERLESS_MODIFIED_AT: TableField<DocumentSourceRecord, OffsetDateTime?> =
    createField(DSL.name("paperless_modified_at"), SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false), this, "")

  /**
   * The column <code>paperless_rag.document_source.last_ingested_at</code>.
   */
  val LAST_INGESTED_AT: TableField<DocumentSourceRecord, OffsetDateTime?> =
    createField(DSL.name("last_ingested_at"), SQLDataType.TIMESTAMPWITHTIMEZONE(6), this, "")

  /**
   * The column <code>paperless_rag.document_source.status</code>.
   */
  val STATUS: TableField<DocumentSourceRecord, String?> = createField(
    DSL.name("status"),
    SQLDataType.CLOB.nullable(false).defaultValue(DSL.field(DSL.raw("'PENDING'::text"), SQLDataType.CLOB)),
    this,
    ""
  )

  /**
   * The column <code>paperless_rag.document_source.error_message</code>.
   */
  val ERROR_MESSAGE: TableField<DocumentSourceRecord, String?> =
    createField(DSL.name("error_message"), SQLDataType.CLOB, this, "")

  /**
   * The column <code>paperless_rag.document_source.created_at</code>.
   */
  val CREATED_AT: TableField<DocumentSourceRecord, OffsetDateTime?> = createField(
    DSL.name("created_at"),
    SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false)
      .defaultValue(DSL.field(DSL.raw("now()"), SQLDataType.TIMESTAMPWITHTIMEZONE)),
    this,
    ""
  )

  /**
   * The column <code>paperless_rag.document_source.updated_at</code>.
   */
  val UPDATED_AT: TableField<DocumentSourceRecord, OffsetDateTime?> = createField(
    DSL.name("updated_at"),
    SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false)
      .defaultValue(DSL.field(DSL.raw("now()"), SQLDataType.TIMESTAMPWITHTIMEZONE)),
    this,
    ""
  )

  private constructor(alias: Name, aliased: Table<DocumentSourceRecord>?) : this(
    alias,
    null,
    null,
    null,
    aliased,
    null,
    null
  )

  private constructor(alias: Name, aliased: Table<DocumentSourceRecord>?, parameters: Array<Field<*>?>?) : this(
    alias,
    null,
    null,
    null,
    aliased,
    parameters,
    null
  )

  private constructor(alias: Name, aliased: Table<DocumentSourceRecord>?, where: Condition?) : this(
    alias,
    null,
    null,
    null,
    aliased,
    null,
    where
  )

  /**
   * Create an aliased <code>paperless_rag.document_source</code> table
   * reference
   */
  constructor(alias: String) : this(DSL.name(alias))

  /**
   * Create an aliased <code>paperless_rag.document_source</code> table
   * reference
   */
  constructor(alias: Name) : this(alias, null)

  /**
   * Create a <code>paperless_rag.document_source</code> table reference
   */
  constructor() : this(DSL.name("document_source"), null)

  constructor(
    path: Table<out Record>,
    childPath: ForeignKey<out Record, DocumentSourceRecord>?,
    parentPath: InverseForeignKey<out Record, DocumentSourceRecord>?
  ) : this(
    Internal.createPathAlias(path, childPath, parentPath),
    path,
    childPath,
    parentPath,
    DOCUMENT_SOURCE,
    null,
    null
  )

  /**
   * A subtype implementing {@link Path} for simplified path-based joins.
   */
  open class DocumentSourcePath : DocumentSource, Path<DocumentSourceRecord> {
    constructor(
      path: Table<out Record>,
      childPath: ForeignKey<out Record, DocumentSourceRecord>?,
      parentPath: InverseForeignKey<out Record, DocumentSourceRecord>?
    ) : super(path, childPath, parentPath)

    private constructor(alias: Name, aliased: Table<DocumentSourceRecord>) : super(alias, aliased)

    override fun `as`(alias: String): DocumentSourcePath = DocumentSourcePath(DSL.name(alias), this)
    override fun `as`(alias: Name): DocumentSourcePath = DocumentSourcePath(alias, this)
    override fun `as`(alias: Table<*>): DocumentSourcePath = DocumentSourcePath(alias.qualifiedName, this)
  }

  override fun getSchema(): Schema? = if (aliased()) null else PaperlessRag.PAPERLESS_RAG
  override fun getIndexes(): List<Index> = listOf(IDX_DOCUMENT_SOURCE_MODIFIED, IDX_DOCUMENT_SOURCE_STATUS)
  override fun getIdentity(): Identity<DocumentSourceRecord, Long?> =
    super.getIdentity() as Identity<DocumentSourceRecord, Long?>

  override fun getPrimaryKey(): UniqueKey<DocumentSourceRecord> = DOCUMENT_SOURCE_PKEY
  override fun getUniqueKeys(): List<UniqueKey<DocumentSourceRecord>> = listOf(DOCUMENT_SOURCE_PAPERLESS_DOC_ID_KEY)

  private lateinit var _documentChunk: DocumentChunkPath

  /**
   * Get the implicit to-many join path to the
   * <code>paperless_rag.document_chunk</code> table
   */
  fun documentChunk(): DocumentChunkPath {
    if (!this::_documentChunk.isInitialized)
      _documentChunk = DocumentChunkPath(this, null, DOCUMENT_CHUNK__DOCUMENT_CHUNK_DOCUMENT_SOURCE_ID_FKEY.inverseKey)

    return _documentChunk;
  }

  val documentChunk: DocumentChunkPath
    get(): DocumentChunkPath = documentChunk()

  override fun `as`(alias: String): DocumentSource = DocumentSource(DSL.name(alias), this)
  override fun `as`(alias: Name): DocumentSource = DocumentSource(alias, this)
  override fun `as`(alias: Table<*>): DocumentSource = DocumentSource(alias.qualifiedName, this)

  /**
   * Rename this table
   */
  override fun rename(name: String): DocumentSource = DocumentSource(DSL.name(name), null)

  /**
   * Rename this table
   */
  override fun rename(name: Name): DocumentSource = DocumentSource(name, null)

  /**
   * Rename this table
   */
  override fun rename(name: Table<*>): DocumentSource = DocumentSource(name.qualifiedName, null)

  /**
   * Create an inline derived table from this table
   */
  override fun where(condition: Condition?): DocumentSource =
    DocumentSource(qualifiedName, if (aliased()) this else null, condition)

  /**
   * Create an inline derived table from this table
   */
  override fun where(conditions: Collection<Condition>): DocumentSource = where(DSL.and(conditions))

  /**
   * Create an inline derived table from this table
   */
  override fun where(vararg conditions: Condition?): DocumentSource = where(DSL.and(*conditions))

  /**
   * Create an inline derived table from this table
   */
  override fun where(condition: Field<Boolean?>?): DocumentSource = where(DSL.condition(condition))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(condition: SQL): DocumentSource = where(DSL.condition(condition))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(@Stringly.SQL condition: String): DocumentSource = where(DSL.condition(condition))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(@Stringly.SQL condition: String, vararg binds: Any?): DocumentSource =
    where(DSL.condition(condition, *binds))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(@Stringly.SQL condition: String, vararg parts: QueryPart): DocumentSource =
    where(DSL.condition(condition, *parts))

  /**
   * Create an inline derived table from this table
   */
  override fun whereExists(select: Select<*>): DocumentSource = where(DSL.exists(select))

  /**
   * Create an inline derived table from this table
   */
  override fun whereNotExists(select: Select<*>): DocumentSource = where(DSL.notExists(select))
}

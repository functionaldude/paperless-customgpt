/*
 * This file is generated by jOOQ.
 */
package com.functionaldude.paperless.jooq.`public`.tables


import org.jooq.*
import org.jooq.impl.*
import org.jooq.impl.Internal
import java.time.OffsetDateTime


/**
 * This class is generated by jOOQ.
 */
@Suppress("UNCHECKED_CAST")
open class AuditlogLogentry(
  alias: Name,
  path: Table<out Record>?,
  childPath: ForeignKey<out Record, com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?,
  parentPath: InverseForeignKey<out Record, com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?,
  aliased: Table<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?,
  parameters: Array<Field<*>?>?,
  where: Condition?
) : TableImpl<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>(
  alias,
  com.functionaldude.paperless.jooq.`public`.Public.PUBLIC,
  path,
  childPath,
  parentPath,
  aliased,
  parameters,
  DSL.comment(""),
  TableOptions.table(),
  where,
) {
  companion object {

    /**
     * The reference instance of <code>public.auditlog_logentry</code>
     */
    val AUDITLOG_LOGENTRY: AuditlogLogentry = AuditlogLogentry()
  }

  /**
   * The class holding records for this type
   */
  override fun getRecordType(): Class<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord> =
    com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord::class.java

  /**
   * The column <code>public.auditlog_logentry.id</code>.
   */
  val ID: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, Int?> =
    createField(DSL.name("id"), SQLDataType.INTEGER.nullable(false).identity(true), this, "")

  /**
   * The column <code>public.auditlog_logentry.object_pk</code>.
   */
  val OBJECT_PK: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, String?> =
    createField(DSL.name("object_pk"), SQLDataType.VARCHAR(255).nullable(false), this, "")

  /**
   * The column <code>public.auditlog_logentry.object_id</code>.
   */
  val OBJECT_ID: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, Long?> =
    createField(DSL.name("object_id"), SQLDataType.BIGINT, this, "")

  /**
   * The column <code>public.auditlog_logentry.object_repr</code>.
   */
  val OBJECT_REPR: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, String?> =
    createField(DSL.name("object_repr"), SQLDataType.CLOB.nullable(false), this, "")

  /**
   * The column <code>public.auditlog_logentry.action</code>.
   */
  val ACTION: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, Short?> =
    createField(DSL.name("action"), SQLDataType.SMALLINT.nullable(false), this, "")

  /**
   * The column <code>public.auditlog_logentry.changes</code>.
   */
  val CHANGES: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, JSONB?> =
    createField(DSL.name("changes"), SQLDataType.JSONB, this, "")

  /**
   * The column <code>public.auditlog_logentry.timestamp</code>.
   */
  val TIMESTAMP: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, OffsetDateTime?> =
    createField(DSL.name("timestamp"), SQLDataType.TIMESTAMPWITHTIMEZONE(6).nullable(false), this, "")

  /**
   * The column <code>public.auditlog_logentry.actor_id</code>.
   */
  val ACTOR_ID: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, Int?> =
    createField(DSL.name("actor_id"), SQLDataType.INTEGER, this, "")

  /**
   * The column <code>public.auditlog_logentry.content_type_id</code>.
   */
  val CONTENT_TYPE_ID: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, Int?> =
    createField(DSL.name("content_type_id"), SQLDataType.INTEGER.nullable(false), this, "")

  @Deprecated(message = "Unknown data type. If this is a qualified, user-defined type, it may have been excluded from code generation. If this is a built-in type, you can define an explicit org.jooq.Binding to specify how this type should be handled. Deprecation can be turned off using <deprecationOnUnknownTypes/> in your code generator configuration.")
  val REMOTE_ADDR: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, Any?> =
    createField(DSL.name("remote_addr"), DefaultDataType.getDefaultDataType("\"pg_catalog\".\"inet\""), this, "")

  /**
   * The column <code>public.auditlog_logentry.additional_data</code>.
   */
  val ADDITIONAL_DATA: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, JSONB?> =
    createField(DSL.name("additional_data"), SQLDataType.JSONB, this, "")

  /**
   * The column <code>public.auditlog_logentry.serialized_data</code>.
   */
  val SERIALIZED_DATA: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, JSONB?> =
    createField(DSL.name("serialized_data"), SQLDataType.JSONB, this, "")

  /**
   * The column <code>public.auditlog_logentry.cid</code>.
   */
  val CID: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, String?> =
    createField(DSL.name("cid"), SQLDataType.VARCHAR(255), this, "")

  /**
   * The column <code>public.auditlog_logentry.changes_text</code>.
   */
  val CHANGES_TEXT: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, String?> =
    createField(DSL.name("changes_text"), SQLDataType.CLOB.nullable(false), this, "")

  /**
   * The column <code>public.auditlog_logentry.remote_port</code>.
   */
  val REMOTE_PORT: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, Int?> =
    createField(DSL.name("remote_port"), SQLDataType.INTEGER, this, "")

  /**
   * The column <code>public.auditlog_logentry.actor_email</code>.
   */
  val ACTOR_EMAIL: TableField<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, String?> =
    createField(DSL.name("actor_email"), SQLDataType.VARCHAR(254), this, "")

  private constructor(
    alias: Name,
    aliased: Table<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?
  ) : this(alias, null, null, null, aliased, null, null)

  private constructor(
    alias: Name,
    aliased: Table<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?,
    parameters: Array<Field<*>?>?
  ) : this(alias, null, null, null, aliased, parameters, null)

  private constructor(
    alias: Name,
    aliased: Table<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?,
    where: Condition?
  ) : this(alias, null, null, null, aliased, null, where)

  /**
   * Create an aliased <code>public.auditlog_logentry</code> table reference
   */
  constructor(alias: String) : this(DSL.name(alias))

  /**
   * Create an aliased <code>public.auditlog_logentry</code> table reference
   */
  constructor(alias: Name) : this(alias, null)

  /**
   * Create a <code>public.auditlog_logentry</code> table reference
   */
  constructor() : this(DSL.name("auditlog_logentry"), null)

  constructor(
    path: Table<out Record>,
    childPath: ForeignKey<out Record, com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?,
    parentPath: InverseForeignKey<out Record, com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?
  ) : this(
    Internal.createPathAlias(path, childPath, parentPath),
    path,
    childPath,
    parentPath,
    AUDITLOG_LOGENTRY,
    null,
    null
  )

  /**
   * A subtype implementing {@link Path} for simplified path-based joins.
   */
  open class AuditlogLogentryPath : AuditlogLogentry,
    Path<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord> {
    constructor(
      path: Table<out Record>,
      childPath: ForeignKey<out Record, com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?,
      parentPath: InverseForeignKey<out Record, com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>?
    ) : super(path, childPath, parentPath)

    private constructor(
      alias: Name,
      aliased: Table<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>
    ) : super(alias, aliased)

    override fun `as`(alias: String): AuditlogLogentryPath = AuditlogLogentryPath(DSL.name(alias), this)
    override fun `as`(alias: Name): AuditlogLogentryPath = AuditlogLogentryPath(alias, this)
    override fun `as`(alias: Table<*>): AuditlogLogentryPath = AuditlogLogentryPath(alias.qualifiedName, this)
  }

  override fun getSchema(): Schema? = if (aliased()) null else com.functionaldude.paperless.jooq.`public`.Public.PUBLIC
  override fun getIndexes(): List<Index> = listOf(
    com.functionaldude.paperless.jooq.`public`.indexes.AUDITLOG_LOGENTRY_ACTION_229AFE39,
    com.functionaldude.paperless.jooq.`public`.indexes.AUDITLOG_LOGENTRY_ACTOR_ID_959271D2,
    com.functionaldude.paperless.jooq.`public`.indexes.AUDITLOG_LOGENTRY_CID_9F467263,
    com.functionaldude.paperless.jooq.`public`.indexes.AUDITLOG_LOGENTRY_CID_9F467263_LIKE,
    com.functionaldude.paperless.jooq.`public`.indexes.AUDITLOG_LOGENTRY_CONTENT_TYPE_ID_75830218,
    com.functionaldude.paperless.jooq.`public`.indexes.AUDITLOG_LOGENTRY_OBJECT_ID_09C2EEE8,
    com.functionaldude.paperless.jooq.`public`.indexes.AUDITLOG_LOGENTRY_OBJECT_PK_6E3219C0,
    com.functionaldude.paperless.jooq.`public`.indexes.AUDITLOG_LOGENTRY_OBJECT_PK_6E3219C0_LIKE,
    com.functionaldude.paperless.jooq.`public`.indexes.AUDITLOG_LOGENTRY_TIMESTAMP_37867BB0
  )

  override fun getIdentity(): Identity<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, Int?> =
    super.getIdentity() as Identity<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, Int?>

  override fun getPrimaryKey(): UniqueKey<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord> =
    com.functionaldude.paperless.jooq.`public`.keys.AUDITLOG_LOGENTRY_PKEY

  override fun getReferences(): List<ForeignKey<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord, *>> =
    listOf(
      com.functionaldude.paperless.jooq.`public`.keys.AUDITLOG_LOGENTRY__AUDITLOG_LOGENTRY_ACTOR_ID_959271D2_FK_AUTH_USER_ID,
      com.functionaldude.paperless.jooq.`public`.keys.AUDITLOG_LOGENTRY__AUDITLOG_LOGENTRY_CONTENT_TYPE_ID_75830218_FK_DJANGO_CO
    )

  private lateinit var _authUser: com.functionaldude.paperless.jooq.`public`.tables.AuthUser.AuthUserPath

  /**
   * Get the implicit join path to the <code>public.auth_user</code> table.
   */
  fun authUser(): com.functionaldude.paperless.jooq.`public`.tables.AuthUser.AuthUserPath {
    if (!this::_authUser.isInitialized)
      _authUser = com.functionaldude.paperless.jooq.`public`.tables.AuthUser.AuthUserPath(
        this,
        com.functionaldude.paperless.jooq.`public`.keys.AUDITLOG_LOGENTRY__AUDITLOG_LOGENTRY_ACTOR_ID_959271D2_FK_AUTH_USER_ID,
        null
      )

    return _authUser;
  }

  val authUser: com.functionaldude.paperless.jooq.`public`.tables.AuthUser.AuthUserPath
    get(): com.functionaldude.paperless.jooq.`public`.tables.AuthUser.AuthUserPath = authUser()

  private lateinit var _djangoContentType: com.functionaldude.paperless.jooq.`public`.tables.DjangoContentType.DjangoContentTypePath

  /**
   * Get the implicit join path to the <code>public.django_content_type</code>
   * table.
   */
  fun djangoContentType(): com.functionaldude.paperless.jooq.`public`.tables.DjangoContentType.DjangoContentTypePath {
    if (!this::_djangoContentType.isInitialized)
      _djangoContentType = com.functionaldude.paperless.jooq.`public`.tables.DjangoContentType.DjangoContentTypePath(
        this,
        com.functionaldude.paperless.jooq.`public`.keys.AUDITLOG_LOGENTRY__AUDITLOG_LOGENTRY_CONTENT_TYPE_ID_75830218_FK_DJANGO_CO,
        null
      )

    return _djangoContentType;
  }

  val djangoContentType: com.functionaldude.paperless.jooq.`public`.tables.DjangoContentType.DjangoContentTypePath
    get(): com.functionaldude.paperless.jooq.`public`.tables.DjangoContentType.DjangoContentTypePath = djangoContentType()

  override fun getChecks(): List<Check<com.functionaldude.paperless.jooq.`public`.tables.records.AuditlogLogentryRecord>> =
    listOf(
      Internal.createCheck(this, DSL.name("auditlog_logentry_action_check"), "((action >= 0))", true),
      Internal.createCheck(this, DSL.name("auditlog_logentry_remote_port_check"), "((remote_port >= 0))", true)
    )

  override fun `as`(alias: String): AuditlogLogentry = AuditlogLogentry(DSL.name(alias), this)
  override fun `as`(alias: Name): AuditlogLogentry = AuditlogLogentry(alias, this)
  override fun `as`(alias: Table<*>): AuditlogLogentry = AuditlogLogentry(alias.qualifiedName, this)

  /**
   * Rename this table
   */
  override fun rename(name: String): AuditlogLogentry = AuditlogLogentry(DSL.name(name), null)

  /**
   * Rename this table
   */
  override fun rename(name: Name): AuditlogLogentry = AuditlogLogentry(name, null)

  /**
   * Rename this table
   */
  override fun rename(name: Table<*>): AuditlogLogentry = AuditlogLogentry(name.qualifiedName, null)

  /**
   * Create an inline derived table from this table
   */
  override fun where(condition: Condition?): AuditlogLogentry =
    AuditlogLogentry(qualifiedName, if (aliased()) this else null, condition)

  /**
   * Create an inline derived table from this table
   */
  override fun where(conditions: Collection<Condition>): AuditlogLogentry = where(DSL.and(conditions))

  /**
   * Create an inline derived table from this table
   */
  override fun where(vararg conditions: Condition?): AuditlogLogentry = where(DSL.and(*conditions))

  /**
   * Create an inline derived table from this table
   */
  override fun where(condition: Field<Boolean?>?): AuditlogLogentry = where(DSL.condition(condition))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(condition: SQL): AuditlogLogentry = where(DSL.condition(condition))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(@Stringly.SQL condition: String): AuditlogLogentry = where(DSL.condition(condition))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(@Stringly.SQL condition: String, vararg binds: Any?): AuditlogLogentry =
    where(DSL.condition(condition, *binds))

  /**
   * Create an inline derived table from this table
   */
  @PlainSQL
  override fun where(@Stringly.SQL condition: String, vararg parts: QueryPart): AuditlogLogentry =
    where(DSL.condition(condition, *parts))

  /**
   * Create an inline derived table from this table
   */
  override fun whereExists(select: Select<*>): AuditlogLogentry = where(DSL.exists(select))

  /**
   * Create an inline derived table from this table
   */
  override fun whereNotExists(select: Select<*>): AuditlogLogentry = where(DSL.notExists(select))
}
